package uk.ac.warwick.dcs.sherlock.api.model.postprocessing;

import uk.ac.warwick.dcs.sherlock.api.SherlockHelper;
import uk.ac.warwick.dcs.sherlock.api.common.ICodeBlockGroup;
import uk.ac.warwick.dcs.sherlock.api.common.ISourceFile;
import uk.ac.warwick.dcs.sherlock.api.model.scoring.IScoreFunction;

import java.util.*;
import java.util.stream.*;

/**
 * Processed results for a task (for a single IDetector instance)
 * <p>
 * Each file in this should be scored for its performance only in this task
 */
public class ModelTaskProcessedResults {

	private IScoreFunction scorer;
	private List<ICodeBlockGroup> groups;

	/**
	 * @param scorer TODO: look to make it possible to support multiple scorers in a single PostProcessor depending on the detector used
	 */
	public ModelTaskProcessedResults(IScoreFunction scorer) {
		this.scorer = scorer;
		this.groups = new LinkedList<>();
	}

	/**
	 * Creates a new ICodeBlockGroup instance, adds it to the results list and returns it
	 *
	 * @return the new instance
	 */
	public ICodeBlockGroup addGroup() {
		try {
			ICodeBlockGroup g = SherlockHelper.getInstanceOfCodeBlockGroup();
			this.groups.add(g);
			return g;
		}
		catch (IllegalAccessException | InstantiationException e) {
			e.printStackTrace(); // couldn't create group
		}

		return null;
	}

	/**
	 * @return the final list of {@link ICodeBlockGroup} produced by the task
	 */
	public List<ICodeBlockGroup> getGroups() {
		return groups;
	}

	/**
	 * Remove a group from the list of groups
	 * @param group group to remove
	 */
	public void removeGroup(ICodeBlockGroup group) {
		if (group != null) {
			this.groups.remove(group);
		}
	}

	/**
	 * Fetches a list of groups containing the passed file
	 *
	 * @param file file present in all groups
	 * @return list of groups
	 */
	public List<ICodeBlockGroup> getGroups(ISourceFile file) {
		return groups.stream().filter(g -> g.filePresent(file)).collect(Collectors.toList());
	}

	/**
	 * Fetches a list of groups containing the passed files
	 *
	 * @param file1 file present in all groups
	 * @param file2 file present in all groups
	 * @return list of groups
	 */
	public List<ICodeBlockGroup> getGroups(ISourceFile file1, ISourceFile file2) {
		return groups.stream().filter(g -> g.filePresent(file1) && g.filePresent(file2)).collect(Collectors.toList());
	}

	/**
	 * @return the scorer instance generated by the post processor
	 */
	public IScoreFunction getScorer() {
		return scorer;
	}

	/**
	 * Remove any empty groups from the list
	 */
	public boolean cleanGroups() {
		this.groups = this.groups.stream().filter(ICodeBlockGroup::isPopulated).collect(Collectors.toList());
		return this.groups.stream().anyMatch(x -> x.getDetectionType() == null);
	}
}
